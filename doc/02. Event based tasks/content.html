<p>Jedną z pr&oacute;b ogarnięcia asynchroniczności było wykorzystanie mechanizmu zdarzeń (event). Onegdaj istniały takie technologie jak WCF - służący do wystawiania na świat&nbsp;API po http oraz Silverlight, kt&oacute;ry miał robić to co dzisiaj <s>Flash</s> javascript. I jak się generowało klasy pozwalające korzystać z API WCF w SL to wynikowe klasy przypominały taki kod:</p>

<div class="code"><pre class="prettyprint lang-cs">public class Proxy
{
&nbsp;&nbsp;&nbsp;&nbsp;void Method1(int argument);
&nbsp;&nbsp;&nbsp;&nbsp;event EventHandler&lt;EventArgs&lt;Result1&gt;&gt; Method1Completed;
&nbsp;&nbsp;&nbsp;&nbsp;event EventHandler&lt;FailureEventArgs&gt; Method1Failed;

&nbsp;&nbsp;&nbsp;&nbsp;void Method2();
&nbsp;&nbsp;&nbsp;&nbsp;event EventHandler&lt;EventArgs&lt;Result2&gt;&gt; Method1Completed;
&nbsp;&nbsp;&nbsp;&nbsp;event EventHandler&lt;FailureEventArgs&gt; Method1Failed;
}</pre></div>

<p>Ale poczułem się staro. Podobny wzorzec był stosowany też w innych technologiach. Ma on wiele wad w por&oacute;wnaniu do kolbak&oacute;w. Na początek nie istnieje żadna gwarancja że jeżeli wywołam Method1 z argumentem 1 po czym wywołam Method1 z argumentem 2 to event Method1Completed dla 1 przyjdzie przed tym samym eventem dla 2. Na potrzeby dalszych rozważań uznam, że opakowanie w Task i użycie sł&oacute;w async i await sprawi że wywołanie z 2 nie nastąpi przez eventem dla 1, co nie musi być prawdą ale zazwyczaj jest.</p>

<p>Podejście to sprawdza się nie źle w jednym przypadku: akcja się wywołuje jak się uda podejmowane jest jedno zawsze to samo działanie, jak nie to drugie.</p>

<div class="code"><pre class="prettyprint lang-cs">// Constructor
public ClientClass()
{
&nbsp;&nbsp;&nbsp;&nbsp;_eventApi = new EventApi();
&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntCompleted += EventApiOnGetNextIntCompleted;
&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntFailed += EventApiOnGetNextIntFailed;
}

private void EventApiOnGetNextIntCompleted(object sender, ResultEventArgs resultEventArgs)
{
&nbsp;&nbsp;&nbsp;&nbsp;MessageBox.Show(resultEventArgs.Result);
}

private void EventApiOnGetNextIntFailed(object sender, FailureEventArgs failureEventArgs)
{
&nbsp;&nbsp;&nbsp;&nbsp;MessageBox.Show(&quot;Something gone wrong&quot;);
}</pre></div>

<p>Sytuacja jednak komplikuje się znacząco gdy w momencie zakończenia zadania potrzebna jest informacja znana przy jego rozpoczęciu:</p>

<div class="code"><pre class="prettyprint lang-cs">public void GetNextIntForClient(Client client)
{
&nbsp;&nbsp;&nbsp;&nbsp;EventHandler&lt;ResultEventArgs&gt; successHandler = null;
&nbsp;&nbsp;&nbsp;&nbsp;EventHandler&lt;FailureEventArgs&gt; failureHandler = null;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;successHandler = (sender, args) =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntCompleted -= successHandler;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntFailed -= failureHandler;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox.Show(string.Format(&quot;{1} was chosen for client {0}&quot;, client.Name, args.Result));
&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;failureHandler = (sender, args) =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntCompleted -= successHandler;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntFailed -= failureHandler;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox.Show(string.Format(&quot;Unable to choose value for client {0}&quot;, client.Name));
&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntCompleted += successHandler;
&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntFailed += failureHandler;

&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextInt();
}</pre></div>

<p>Dla por&oacute;wnania kod oparty o async/await</p>

<div class="code"><pre class="prettyprint lang-cs">public async void GetNextIntForClient(Client client)
{
&nbsp;&nbsp;&nbsp;&nbsp;try
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await _taskApi.GetNextInt();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox.Show(string.Format(&quot;{1} was chosen for client {0}&quot;, client.Name, args.Result));
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;catch (Exception exception)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MessageBox.Show(string.Format(&quot;Unable to choose value for client {0}&quot;, client.Name));
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre></div>

<p>Opakowanie zdarzeń w zadania nie jest proste i opiera się na kodzie podobnym do tego w metodzie GetNextIntForClient:</p>

<div class="code"><pre class="prettyprint lang-cs">public Task&lt;int&gt; GetNextInt()
{
&nbsp;&nbsp;&nbsp;&nbsp;var completionSource = new TaskCompletionSource&lt;int&gt;();

&nbsp;&nbsp;&nbsp;&nbsp;EventHandler&lt;ResultEventArgs&gt; successHandler = null;
&nbsp;&nbsp;&nbsp;&nbsp;EventHandler&lt;FailureEventArgs&gt; failureHandler = null;

&nbsp;&nbsp;&nbsp;&nbsp;successHandler = (sender, args) =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntCompleted -= successHandler;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntFailed -= failureHandler;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completionSource.TrySetResult(args.Result);
&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;failureHandler = (sender, args) =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntCompleted -= successHandler;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntFailed -= failureHandler;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completionSource.TrySetException(args.Error);
&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntCompleted += successHandler;
&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextIntFailed += failureHandler;

&nbsp;&nbsp;&nbsp;&nbsp;_eventApi.GetNextInt();

&nbsp;&nbsp;&nbsp;&nbsp;return completionSource.Task;
}</pre></div>

<p>Sporo kodu... wypadałoby go skrócić. Napisanie uniwersalnego helpera jest jednak trudniejsze niż się wydaje. Jednym z problemów jest, wspomiany <a href="https://szogun1987.pl/show/Spotkanie-z-TaskCompletionSource-Cz-1-I-promise-I-will-call-back/34">w poprzednim artykule</a>, brak mapowania delegat &quot;w locie&quot;. Z moich doświadczeń wynika jednak, że twórcy API zazwyczaj korzystają z typów: EventHandler oraz EventHandler&lt;T&gt;, a nawet jeżeli używają innych typów to są spójni w zakresie swojego API. Więc taki helper:</p>
<div class="code"><pre class="prettyprint lang-cs">public class EventToTask&lt;TResult&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;private readonly Action&lt;EventHandler&lt;TResult&gt;&gt; _subscribe;
&nbsp;&nbsp;&nbsp;&nbsp;private readonly Action&lt;EventHandler&lt;TResult&gt;&gt; _unsubscribe;
&nbsp;&nbsp;&nbsp;&nbsp;private readonly Action&lt;EventHandler&lt;FailureEventArgs&gt;&gt; _subscribeFailure;
&nbsp;&nbsp;&nbsp;&nbsp;private readonly Action&lt;EventHandler&lt;FailureEventArgs&gt;&gt; _unsubscribeFailure;
&nbsp;&nbsp;&nbsp;&nbsp;private readonly Action _trigger;
&nbsp;&nbsp;&nbsp;&nbsp;public EventToTask(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action&lt;EventHandler&lt;TResult&gt;&gt; subscribe,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action&lt;EventHandler&lt;TResult&gt;&gt; unsubscribe,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action&lt;EventHandler&lt;FailureEventArgs&gt;&gt; subscribeFailure,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action&lt;EventHandler&lt;FailureEventArgs&gt;&gt; unsubscribeFailure,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action trigger)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_subscribe = subscribe;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_unsubscribe = unsubscribe;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_subscribeFailure = subscribeFailure;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_unsubscribeFailure = unsubscribeFailure;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_trigger = trigger;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public Task&lt;TResult&gt; Invoke()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var completionSource = new TaskCompletionSource&lt;TResult&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventHandler&lt;TResult&gt; successHandler = null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventHandler&lt;FailureEventArgs&gt; failureHandler = null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;successHandler = (sender, args) =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_unsubscribe(successHandler);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_unsubscribeFailure(failureHandler);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completionSource.TrySetResult(args);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;failureHandler = (sender, args) =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_unsubscribe(successHandler);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_unsubscribeFailure(failureHandler);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completionSource.TrySetException(args.Error);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_subscribe(successHandler);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_subscribeFailure(failureHandler);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_trigger();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return completionSource.Task;
&nbsp;&nbsp;&nbsp;&nbsp;}
}</pre></div>
<p>sprawi że opakowanie API opartego o eventy w zadania skróci się do:</p>
<div class="code"><pre class="prettyprint lang-cs">public async Task&lt;int&gt; GetNextIntWithArg(string arg)
{
&nbsp;&nbsp;&nbsp;&nbsp;var eventToTask = new EventToTask&lt;ResultEventArgs&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler =&gt; _eventApi.GetNextIntCompleted += handler,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler =&gt; _eventApi.GetNextIntCompleted -= handler,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler =&gt; _eventApi.GetNextIntFailed += handler,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler =&gt; _eventApi.GetNextIntFailed -= handler,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;() =&gt; _eventApi.GetNextInt());
&nbsp;&nbsp;&nbsp;&nbsp;var eventArgs = await eventToTask.Invoke();
&nbsp;&nbsp;&nbsp;&nbsp;return eventArgs.Result;
}</pre></div>
<p>Znacznie lepiej ale dalej fatalnie. Problemem, który widać na pierwszy rzut oka, jest konieczność pisania powtarzalnego kodu w którym łatwo się pomylić. W dodatku w przypadku pomyłki programista nie zostanie ostrzeżony podczas kompilacji, ten błąd może zostać także niezauważony przez długi czas przez wszystkie formy testu i objawić się wyciekiem pamięci albo trudnym do odtworzenia crashem. Drugim problemem, którego nie widać, jest fakt iż kompilator wygeneruje na potrzeby tego kodu 6 klas których obiekty będzie tworzył przy wywołaniu tej metody. Zazwyczaj nie jest to duży problem ale można go łatwo ograniczyć zmieniając implementację EventToTask.</p>

<div class="code"><pre class="prettyprint lang-cs">public class EventToTask&lt;TContext, TResult&gt;
{
&nbsp;&nbsp;&nbsp;&nbsp;private readonly TContext _context;
&nbsp;&nbsp;&nbsp;&nbsp;private readonly Action&lt;TContext, EventHandler&lt;TResult&gt;&gt; _subscribe;
&nbsp;&nbsp;&nbsp;&nbsp;private readonly Action&lt;TContext, EventHandler&lt;TResult&gt;&gt; _unsubscribe;
&nbsp;&nbsp;&nbsp;&nbsp;private readonly Action&lt;TContext, EventHandler&lt;FailureEventArgs&gt;&gt; _subscribeFailure;
&nbsp;&nbsp;&nbsp;&nbsp;private readonly Action&lt;TContext, EventHandler&lt;FailureEventArgs&gt;&gt; _unsubscribeFailure;
&nbsp;&nbsp;&nbsp;&nbsp;private readonly Action&lt;TContext&gt; _trigger;

&nbsp;&nbsp;&nbsp;&nbsp;public EventToTask(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TContext context,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action&lt;TContext, EventHandler&lt;TResult&gt;&gt; subscribe,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action&lt;TContext, EventHandler&lt;TResult&gt;&gt; unsubscribe,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action&lt;TContext, EventHandler&lt;FailureEventArgs&gt;&gt; subscribeFailure,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action&lt;TContext, EventHandler&lt;FailureEventArgs&gt;&gt; unsubscribeFailure,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Action&lt;TContext&gt; trigger)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_context = context;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_subscribe = subscribe;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_unsubscribe = unsubscribe;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_subscribeFailure = subscribeFailure;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_unsubscribeFailure = unsubscribeFailure;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_trigger = trigger;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;public Task&lt;TResult&gt; Invoke()
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var completionSource = new TaskCompletionSource&lt;TResult&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventHandler&lt;TResult&gt; successHandler = null;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EventHandler&lt;FailureEventArgs&gt; failureHandler = null;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;successHandler = (sender, args) =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_unsubscribe(_context, successHandler);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_unsubscribeFailure(_context, failureHandler);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completionSource.TrySetResult(args);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;failureHandler = (sender, args) =&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_unsubscribe(_context, successHandler);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_unsubscribeFailure(_context, failureHandler);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;completionSource.TrySetException(args.Error);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_subscribe(_context, successHandler);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_subscribeFailure(_context, failureHandler);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_trigger(_context);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return completionSource.Task;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</pre></div>
<p>Użycie wygląda podobnie:</p>
<div class="code"><pre class="prettyprint lang-cs">var eventToTask = new EventToTask&lt;EventApi, ResultEventArgs&gt;(
&nbsp;&nbsp;&nbsp;&nbsp;_eventApi,
&nbsp;&nbsp;&nbsp;&nbsp;(context, handler) =&gt; context.GetNextIntCompleted += handler,
&nbsp;&nbsp;&nbsp;&nbsp;(context, handler) =&gt; context.GetNextIntCompleted -= handler,
&nbsp;&nbsp;&nbsp;&nbsp;(context, handler) =&gt; context.GetNextIntFailed += handler,
&nbsp;&nbsp;&nbsp;&nbsp;(context, handler) =&gt; context.GetNextIntFailed -= handler,
&nbsp;&nbsp;&nbsp;&nbsp;context =&gt; context.GetNextInt());
&nbsp;&nbsp;&nbsp;&nbsp;
var eventArgs = await eventToTask.Invoke();
return eventArgs.Result;</pre></div>

<p>Sposobem na zwiększenie wykrywalności i zmniejszenie występowania problemów związanych z pomyłkami programisty w tym kodzie wydaje się być użycie klasy Expression. Przykładowy kod jest trochę przy długi zapraszam do zapoznania się znim na <a href="https://github.com/szogun1987/events-and-tasks/tree/master/src/Szogun1987.EventsAndTasks.NonBuilding/Events/EventToTask.cs">Githubie</a></p>

<p>Użycie tej klasy jest dość proste:</p>
<div class="code"><pre class="prettyprint lang-cs">var eventToTask = EventToTask
&nbsp;&nbsp;&nbsp;&nbsp;.Create(_eventApi)
&nbsp;&nbsp;&nbsp;&nbsp;.WithTrigger(context =&gt; context.GetNextInt())
&nbsp;&nbsp;&nbsp;&nbsp;.WithResultEvent&lt;ResultEventArgs&gt;((context, handler) =&gt; context.GetNextIntCompleted += handler)
&nbsp;&nbsp;&nbsp;&nbsp;.WithFailureEvent((context, handler) =&gt; context.GetNextIntFailed += handler)
&nbsp;&nbsp;&nbsp;&nbsp;.Build();
var eventArgs = await eventToTask.Invoke();
return eventArgs.Result;
</pre></div>

<p>jest tylko jeden taki <sub>malutki problemik</sub>: ten kod się nie kompiluje. Niestety parametr typu Expression&lt;T&gt; nie może przyjąć lambdy zawierającej operator +=. Z drugiej strony po za klasą w której zdarzenie jest deklarowane jedynymi dozwolonymi operatorami które mogą go modyfikować są += i -=.</p>

<p>Podsumowując opieranie asynchroniczności o zdarzenia jest zazwyczaj pomyłką architektoniczną i rodzi problemy. Daje się jednak z nią żyć.</p>

<h2>Kody źr&oacute;dłowe</h2>

<p>Kod źr&oacute;dłowy projektu stworzonego na potrzeby tej serii udostępniam na <a href="https://github.com/szogun1987/events-and-tasks">Githubie</a></p>